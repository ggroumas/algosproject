
Project: Αλγόριθμοι και Δομές Δεδομένων – (2012-2013)

Γενικά
Σε αυτή την εργασία θέλαμε να δοκιμάσουμε τις δυνατότητες οργάνωσης πληροφορίας μέσω των δομών δεδομένων πίνακα κατακερματισμού και συνδεδεμένης λίστας, και να δούμε πως αυτή η οργάνωση βοηθάει στην επεξεργασία δεδομένων μεγάλων σε μέγεθος και με περίπλοκες σχέσεις. Χρησιμοποιήσαμε τη γλώσσα C και κάποιες συναρτήσεις των βιβλιοθηκών για χειρισμό εισόδου-εξόδου (stdio.h), διαχείρισης μνήμης (stdlib.h, string.h) και διαχείρισης συμβολοσειρών (string.h). Η εφαρμογή που κάναμε χρησιμοποιεί την γραμμή εντολών για είσοδο επιλογών του χρήστη μέσα από ένα πολύ απλό μενού επιλογών σχετικό με τις ζητούμενες ενέργειες.

Δομές δεδομένων που χρησιμοποιήσαμε
Χρησιμοποιήσαμε τις εξής δομές δεδομένων:
Συνδεδεμένες Λίστες – Για την διαχείριση πληροφοριών που δε γνωρίζαμε εκ των προτέρων πόσα είναι, οι λίστες είναι ιδανικές. Εύκολη προσάρτηση στοιχείων στο τέλος τους και αριθμός στοιχείων που περιορίζεται μόνο από την μνήμη του συστήματός μας.

Πίνακες Κατακερματισμού – Για την διαχείριση πληροφοριών σχετικών με κάποιο “κλειδί” χρησιμοποιήσαμε πίνακες κατακερματισμού. Παράδειγμα είναι η αντιστοίχιση της τιμής ενός προϊόντος με βάση το όνομα του προϊόντος.
Για τις συνδεδεμένες λίστες μας ορίσαμε τις εξής δομές δεδομένων:
typedef struct my_list * list;
struct my_list {
    void * data;
    list next;
};

Βλέπουμε ότι μια λίστα είναι πολύ απλή. Για να μπορούμε να φτιάχνουμε λίστες με περιεχόμενο που μπορεί να είναι οτιδήποτε ορίσαμε σαν “περιεχόμενο” της λίστας (data) ένα γενικευμένο δείκτη (void *). Έτσι σε αυτή τη δομή μπορούμε άνετα να τοποθετούμε διαφορετικά στοιχεία, αρκεί να ξέρουμε το μέγεθός τους. Σε γενικές γραμμές είναι καλό να αποθηκεύουμε σε μια λίστα στοιχεία ίδιου τύπου και μεγέθους, διαφορετικά τα πράγματα γίνονται γρήγορα πολύ περίπλοκα.
Στο πρόγραμμά μας διατηρούμε δύο λίστες σαν καθολικές μεταβλητές και κάποιες λίστες σαν πεδία άλλων δομών (πχ. Μια δομή αγοράς έχει λίστα με τα αγορασμένα προϊόντα).
Στις συνδεδεμένες λίστες ορίσαμε τις εξής συναρτήσεις χειρισμού (δίνουμε μόνο τα πρότυπά τους):
list list_new();
void list_free(list head);
list list_add(list head, void * data, int data_size);

Δεν ορίσαμε συναρτήσεις για διαγραφή – αναζήτηση καθώς δε χρειαστήκαμε τέτοιες λειτουργίες.

Για τους πίνακες κατακερματισμού ορίσαμε τις εξής δομές δεδομένων.
/* Anaparista mia eggrafh se pinaka katakermatismoy. Gia na mporoyme na ftiaxnoyme pinakes diaforwn eidwn, to periexomeno mias theshs einai mia genikeymenh lista. */
struct hash_entry {
    char * key;
    list elements;
};

/* Anaparista ton pinaka katakermatismoy. Einai sthn oysia enas pinakas apo hash_entry. */
typedef struct my_hash * hash;
struct my_hash {
    int conflicts;
    int num_items;
    struct hash_entry * items;
};

Όπως βλέπετε και στα σχόλια  ένας πίνακας κατακερματισμού είναι ένας πίνακας από στοιχεία τύπου hash_entry. Για τις αντιστοιχίσεις και την αποφυγή συγκρούσεων χρειάζεται κάθε θέση του πίνακα να ξέρει το κλειδί που τις αντιστοιχεί και το στοιχείο που αποθηκεύει, όπως βλέπουμε και στη δομή hash_entry, ενώ ο ίδιος ο πίνακας πρέπει να ξέρει τον αριθμό των στοιχείων του (num_items) και για το τελευταίο ερώτημα της άσκησης τον αριθμό των συγκρούσεων (conflicts). 
Παρατηρείστε επίσης ότι σαν στοιχεία του πίνακα θεωρούμε γενικευμένες λίστες (elements). Αυτό σημαίνει ότι η αντιστοίχιση διαφορετικών τιμών στο ίδιο κλειδί, βάζει τις τιμές στη σχετική λίστα αντί να επαναγράφεται η παλιά τιμή που συνήθως γίνεται στους πίνακες κατακερματισμού.
Στο πρόγραμμά μας έχουμε τρεις πίνακες κατακερματισμού σαν καθολικές μεταβλητές. Ένα πίνακα για τις αγορές προιόντων με κλειδί τον κωδικό κάρτας. Ένα πίνακα για τους συντελεστές των ομάδων προιόντων με κλειδί τον κωδικό ομάδας, και ένα πίνακα για τις τιμές των προϊόντων με κλειδί το όνομα του προϊόντος.
Στον πίνακα κατακερματισμού ορίσαμε τις εξής συναρτήσεις χειρισμού (δίνουμε μόνο τα πρότυπά τους):
unsigned int hash1(const char *str, int max);
hash hash_new(int num_items);
void hash_put(hash h, char * key, void * data, int data_size);
list hash_get(hash h, char * key);
void hash_free(hash h);

Η συνάρτηση κατακερματισμού είναι η hash1 ενώ οι υπόλοιπες κάνουν ότι λένε τα ονόματα των συναρτήσεων, δηλαδή δημιουργία, τοποθέτηση, ανάκτηση και καταστροφή του πίνακα.
Οι υπόλοιπες δομές δεδομένων του προγράμματος αναπαριστούν προϊόντα, αγορές, ομάδες προϊόντων κτλ, και αποτελούν στοιχεία που προσθέτουμε σε λίστες και πίνακες κατακερματισμού, ανάλογα την σημασία που έχει η κάθε δομή. Δεν θα τις αναφέρουμε εδώ καθώς είναι απλές και δεν έχουν κάποια συνδεδεμένη λειτουργικότητα.

Σημεία που αξίζει να αναφέρουμε
Για την είσοδο-έξοδο στο πρόγραμμα, χρησιμοποιήσαμε τις βασικές ρουτίνες της βιβλιοθήκης stdio.h fopen, fclose, fgets. 
Για την διαχείριση μνήμης χρησιμοποιήσαμε τις συναρτήσεις malloc, calloc, free, memcpy.
Ότι είχε σχέση με συμβολοσειρές έγινε με τη βοήθεια των συναρτήσεων strcpy, strcmp, scanf, sscanf, strcat.
Στην ταξινόμηση των υπολογιζόμενων αποτελεσμάτων ράψαμε μια μικρή συνάρτηση που βάζει ένα στοιχείο σε ένα πίνακα δέκα στοιχείων αν είναι μεγαλύτερο από το δέκατο στοιχείο, σπρώχνοντας τα άλλα μια θέση κάτω και απορρίπτοντας το δέκατο στοιχείο. Έτσι όταν τελειώσει ο υπολογισμός, έχουμε ταξινομημένες με φθίνουσα σειρά τις δέκα κάρτες με τα μεγαλύτερα έξοδα.
Στο ερώτημα του υπολογισμού των δώρων μιας ομάδας καρτών, χρησιμοποιήσαμε την συνάρτηση για τον υπολογισμό του κόστους αγορών μιας κάρτας και αθροίσαμε τα κόστη αγορών όλων των καρτών παράγοντας το συνολικό κόστος αγορών της ομάδας καρτών. Ακολούθως συγκρίναμε αυτό το κόστος με το όριο που διαβάσαμε από το αρχείο 5, και τυπώσαμε ανάλογα μηνύματα για τα δώρα (δικαιούνται ή δεν δικαιούνται).
Για το ερώτημα του υπολογισμού των συγκρούσεων αυτό γίνεται στη συνάρτηση hash_put(...). Όταν δει ότι το κλειδί που δόθηκε μπαίνει σε κατειλημμένη θέση που έχει συνδεθεί με άλλο κλειδί, τότε υπάρχει σύγκρουση και αυξάνουμε το μετρητή συγκρούσεων για τον συγκεκριμένο πίνακα κατακερματισμού.

Συμπεράσματα
Παρατηρήσαμε ότι το αρχείο δεδομένων μας είναι αρκετά μεγάλο, όμως η μόνη ενέργεια που απαιτεί κάποιο χρόνο είναι η αναζήτηση των δέκα καλύτερων καρτών. Αυτό συμβαίνει γιατί εκτός από την ταξινόμηση γίνεται ταυτόχρονα και προσπέλαση των άλλων δομών δεδομένων που περιέχουν τιμές, ποσότητες, κατηγορίες, συντελεστές κτλ. Παρ' ολα αυτά με τη χρήση των δομών δεδομένων είδαμε ότι η περιγραφή σε κώδικα των υπολογισμών αυτών, γίνεται αρκετά συνοπτικότερα απ' ότι με παραδοσιακούς τρόπους αποθήκευσης (πχ πίνακες).

